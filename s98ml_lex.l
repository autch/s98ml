/* -*- mode: c; tab-width: 8; -*- */

%{
    #include <stdint.h>
    #include <stdio.h>
    #include <string.h>

    /* generated by Bison, then automake renamed it */
    #include "s98ml_parse.h"
%}

%option reentrant bison-bridge bison-locations noyywrap
%option header-file="s98ml_lex.h"

%x string
%x comment

LOOP_START	\[
LOOP_END	\]
HEX		\$[0-9a-fA-F]+
OCT		\&[0-7]+
DEC		\#?[0-9]+
BIN		\'[01]+
HEX_PAIR	[0-9a-fA-F]{2}:[0-9a-fA-F]{2}

EOL		\n

COLON		\:
COMMA		\,
SLASH		\/


VERSION		#version
TIMER		#timer
TAG		#tag
DEVICE		#device
ENCODING	#encoding

PART		[A-Z]

SYMBOL		[_a-zA-Z0-9]+

%%

<<EOF>>		{ return 0; }

";"		{ BEGIN(comment); yymore(); }
<comment>{EOL}  { BEGIN(INITIAL); return EOL; }
<comment>[^\n]+ { yymore(); }

\"		{ BEGIN(string); }
<string>{EOL}	{ fprintf(stderr, "unterminated quote: %s_n", yytext); BEGIN(INITIAL); return EOL; }
<string>([^\"\n]|\\\"|\\\n)+	{ yymore(); }
<string>\"	{ yytext[yyleng-1] = '\0'; yylval->s = strdup(yytext); BEGIN(INITIAL); return STRING; }

^{VERSION}	{ return VERSION; }
^{TIMER}	{ return TIMER; }
^{TAG}		{ return TAG; }
^{DEVICE}	{ return DEVICE; }
^{ENCODING}	{ return ENCODING; }

{HEX}		{ yylval->n = strtol(yytext + 1, NULL, 16); return HEX; }
{OCT}		{ yylval->n = strtol(yytext + 1, NULL,  8); return OCT; }
{DEC}		{ yylval->n = strtol(yytext[0] == '#' ? yytext + 1 : yytext, NULL, 10); return DEC; }
{BIN}		{ yylval->n = strtol(yytext + 1, NULL,  2); return BIN; }
{HEX_PAIR}	{ 
    yylval->hp.addr = strtol(yytext, NULL, 16);
    yylval->hp.val = strtol(strchr(yytext, ':') + 1, NULL, 16);

    return HEX_PAIR;
}

{COLON}		{ return COLON; }
{COMMA}		{ return COMMA; }
^{SLASH}	{ return SYNC; }
{SLASH}		{ return SLASH; }

^{LOOP_START}	{ return LOOP_START; }
^{LOOP_END}	{ return LOOP_END; }

^{PART}		{ yylval->n = yytext[0] - 'A'; return PART; }

{SYMBOL}	{ yylval->s = strdup(yytext); return SYMBOL; }

{EOL}		{ return EOL; }

[[:blank:]]+	{ /* eat up all spaces */ }

.		{ printf("unrecognized token: \"%s\"\n", yytext); }
